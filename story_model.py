# -*- coding: utf-8 -*-
"""story_model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nL1WwP32ajmKFv9_w_NNplDdXpBqAXUV

# Assignment 3 Top-Level Code/Notebook
### Training a language model base on Karpathy's minGPT codebase
"""

# The code below is needed for using Google Colab, so un comment this if that is what you're using
import nltk
nltk.download('punkt')

# Commented out IPython magic to ensure Python compatibility.
# The code below is also needed for using Google Colab
# BEFORE executing this, you must place the mingpt folder supplied in the assignment
# your google drive, within the folder "Colab Notebooks"
#
# It mounts and changes into the folder that contains mingpt, which you must upload to google drive
# So un-comment it if you've uploaded mingpt to your google drive, into the  "Colab Notebooks" folder
"""
from google.colab import drive
drive.mount('/content/drive')
# %cd /content/drive/MyDrive/Colab\ Notebooks/
"""

!pip install transformers

import torch 
import numpy as np

from nltk.tokenize import sent_tokenize 
from transformers import AutoTokenizer, AutoModelForCausalLM

from pathlib import Path 
from sklearn.model_selection import train_test_split
from torch.utils.data import Dataset
from torch.utils.data.dataloader import DataLoader
from mingpt.bpe import BPETokenizer 
from mingpt.utils import set_seed 
set_seed(1234)

"""
Prepare the dataset to train the Language Model (LM)
This implementation splits the sentences and so doesn't create training 
examples that cross sentences.

This code is set so that it uses one of two possible datasets, which were also used in Assignment 1: 
SmallSimpleCorpus.txt or LargerCorpus.txt

Arguments:
            ds_choice: str. "small" or "large". (i.e. selects which of the two datasets)
            split: str. "train" or "test".
            truncation: int. If -1: no truncation on sentences. Otherwise: truncate to this specific length.
""" 

class LanguageModelingDataset(Dataset):
    
    def __init__(self, ds_choice="small", split="train", truncation=-1):
        
        base_path = "./"
        fn = {"small": "SmallSimpleCorpus.txt", "large": "LargerCorpus.txt", "story": "corpus.txt"}
        self.ds_choice = ds_choice
        self.truncation = truncation  # int. If -1, then
        text = Path(base_path, fn[ds_choice]).read_text()
        if ds_choice == "large":
            # Remove the newline char in the middle of sentences
            # The "paragraph splitting" newlines appear to be \n\n -- remove the duplications there
            text = text.replace("\n\n", "$$^^$$").replace("\n", " ").replace("$$^^$$", "\n")
        sentences = sent_tokenize(text)

        # Train / test split
        train, val = train_test_split(sentences, test_size=0.2, shuffle=False)
        if split == "train":
            raw_data = train 
        else:
            raw_data = val 

        # Tokenize
        # self.tokenizer = BPETokenizer()
                
        # model_name = "pranavpsv/genre-story-generator-v2"
        model_name = "pranavpsv/gpt2-genre-story-generator"
        # model_name = "openai-gpt"
        # model_name = "pranavpsv/gpt2-story-gen"
        # model_name = 'gpt2'

        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.data = []  # List of 1-d pytorch tensor
        for sent in raw_data:
            # print(self.tokenizer(sent))
            tokenized = torch.from_numpy(np.array(self.tokenizer("<superhero> " + sent)["input_ids"])).view(-1)  # pytorch tensor
            if truncation >= 0:
                self.data.append(tokenized[:truncation])
            else:
                self.data.append(tokenized)

        # Count some items
        self.max_sentence_length = np.max([len(d) for d in self.data])

    def __len__(self):
        return len(self.data)

    def get_vocab_size(self):
        """
        We have to set this to the max vocab size (i.e., that decided by the BPE tokenizer), 
        but actually, only a small number of vocab is used, especially for the small text. 
        """
        return 50257

    def __getitem__(self, idx):
        """
        The output should be a tuple x and y, both as pytorch tensors.
        Please refer to the `run()` method in the mingpt/trainer.py script for 
        how the x and y are going to be used.
        """
        x = self.data[idx][:-1]
        y = self.data[idx][1:]
        return (x, y)

    def get_block_size(self):
        """
        block_size is the size at which lines are truncated to ensure they are equal-length.
        """
        return self.max_sentence_length
    
# Instantiate the Training Dataset
# train_dataset = LanguageModelingDataset(ds_choice="small", split="train")  # use this for the short corpus
train_dataset = LanguageModelingDataset(ds_choice="story", split="train", truncation=512) #use this for long

# Instantiate a Validation Dataset (this is only really needed for the fine-tune task, not the LM task)
# val_dataset = LanguageModelingDataset(ds_choice="small", split="validation")
val_dataset = LanguageModelingDataset(ds_choice="story", split="validation", truncation=512)

model_name = "pranavpsv/gpt2-genre-story-generator"

tokenizer = AutoTokenizer.from_pretrained(model_name)

tokenizer

tokenizer("<sci_fi>")

train_dataset[500]

def lm_collate_fn(batch, device='cuda'):
    x = [item[0] for item in batch]  # List (len B) of varying lengths
    y = [item[1] for item in batch]  # List (len B) of the same lengths as x
    maxlen = max([len(s) for s in x])

    padded_x, padded_y = [], []
    for sx, sy in zip(x, y):
        padded_x.append(torch.cat([sx, torch.ones(maxlen - len(sx))]))
        padded_y.append(torch.cat([sy, torch.ones(maxlen - len(sy))]))
    return torch.stack(padded_x).long().to(device), torch.stack(padded_y).long().to(device)

# Print out an example of the data - this is processed more once it reaches lm_collate_fn (above)
x,y = train_dataset[5]
print(x, y)
print("X: ",train_dataset.tokenizer.decode(x))
print("Y: ",train_dataset.tokenizer.decode(y))

from transformers import AutoTokenizer, AutoModelForCausalLM

model_name = "pranavpsv/gpt2-genre-story-generator"
# model_name = "openai-gpt"
# model_name = "pranavpsv/gpt2-story-gen"
# model_name = 'gpt2'

tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForCausalLM.from_pretrained(model_name)

from torch.utils.data import DataLoader
from transformers import DistilBertForSequenceClassification, AdamW

device = torch.device('cuda') if torch.cuda.is_available() else torch.device('cpu')

model.to(device)

model_parameters = filter(lambda p: p.requires_grad, model.parameters())
params = sum([np.prod(p.size()) for p in model_parameters])
print(params)

for param in model.parameters():
    param.requires_grad = False

model.lm_head.weight.requires_grad = True

model_parameters = filter(lambda p: p.requires_grad, model.parameters())
params = sum([np.prod(p.size()) for p in model_parameters])
print(params)

train_loader = DataLoader(train_dataset, batch_size=1, shuffle=True, pin_memory=False)

model.train()

optim = AdamW(model.parameters(), lr=1e-5)
train_loss = []

for epoch in range(3):
    epoch_loss = []
    for batch in train_loader:
        optim.zero_grad()
        input_ids = batch[0].to(device)
        # attention_mask = batch['attention_mask'].to(device)
        labels = batch[1].to(device)
        outputs = model(input_ids,  labels=labels)
        loss = outputs[0]
        loss.backward()
        optim.step()
        epoch_loss.append(loss.item())
    print(epoch_loss)
    train_loss.append(np.mean(epoch_loss))
model.eval()

import matplotlib.pyplot as plt
plt.figure()
plt.xlabel("Epoch")
plt.ylabel("Training Loss")
plt.plot(train_loss)

# Use the trained language model to predict a sequence of words following a few words
encoded_prompt = train_dataset.tokenizer("One day" , return_tensors="pt").to(device)
generated_sequence = model.generate(**encoded_prompt, max_length=400,  do_sample=True)
train_dataset.tokenizer.decode(generated_sequence[0])

import random
begin = ['A long time ago and far,', 'Once upon a time,']
skeletons = ["","","","","But", "After a while,", "However,", "Then,", "So,", "In fact,", "Moreover", "In contrast,", "Consequently,", "Because of", "Furthermore"]
end = ['Finally, ']

# genre = ''
genre = "<action>"
# genre = "<sci_fi>"
# genre = "<horror>"
# genre = "<drama>"

text = genre + " " + random.choice(begin)
flag = True
while flag:
    with torch.no_grad():
        # output = model.generate(**inputs, max_length=200, do_sample=True)

        print(text)
        print("---------------------")
        encoded_prompt = train_dataset.tokenizer("One day" , return_tensors="pt").to(device)
        generated_sequence = model.generate(**encoded_prompt, max_length=400,  do_sample=True)
        new_generated = train_dataset.tokenizer.decode(generated_sequence[0])[len(text):]
        dot_point = new_generated.find('.')
        text = text +  new_generated[:dot_point+1] + ' '
        for w in end:
            if w in text:
                flag = False
        if flag==True:
            if len(text.split(" "))>150:
                text = text + random.choice(end)
            else:
                text = text + random.choice(skeletons)